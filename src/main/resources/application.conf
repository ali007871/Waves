akka {
  loglevel = "INFO"
  loggers = ["akka.event.slf4j.Slf4jLogger"]
  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"
  log-config-on-start = off
  log-dead-letters-during-shutdown = false

  actor {
    debug {
      lifecycle = off
      autoreceive = off
      receive = off
    }

    serializers {
      matcher = "com.wavesplatform.matcher.model.MatcherSerializer"
    }

    serialization-bindings {
      "java.io.Serializable" = none
      "com.wavesplatform.matcher.model.Events$Event" = matcher
      "com.wavesplatform.matcher.market.OrderBookActor$Snapshot" = matcher
      "com.wavesplatform.matcher.market.MatcherActor$OrderBookCreated" = matcher
    }
  }

  http.server.parsing {
    max-method-length = 64
    max-content-length = 1m
  }

  io.tcp {
    direct-buffer-size = 1536 KiB
    trace-logging = off
  }

  persistence {
    journal {
      plugin = akka.persistence.journal.leveldb
      leveldb {
        dir = "target/persistence/journal"
        native = on
      }
    }
    snapshot-store {
      plugin = akka.persistence.snapshot-store.local
      local.dir = "target/persistence/snapshots"
    }
  }
}

# Kamon Metrics
# ~~~~~~~~~~~~~~
kamon {

  metric {

    # Time interval for collecting all metrics and send the snapshots to all subscribed actors.
    tick-interval = 10 seconds

    # Disables a big error message that will be typically logged if your application wasn't started
    # with the -javaagent:/path-to-aspectj-weaver.jar option. If you are only using KamonStandalone
    # it might be ok for you to turn this error off.
    disable-aspectj-weaver-missing-error = false

    # Specify if entities that do not match any include/exclude filter should be tracked.
    track-unmatched-entities = yes

    filters {
      akka-actor {
        includes = ["*/user/OrderHistory*"]
        excludes = [ "*/system/**", "*/user/IO-**", "*kamon*" ]
      }

      akka-router {
        includes = ["*/user/*"]
        excludes = []
      }

      akka-dispatcher {
        includes = ["*/user/*"]
        excludes = []
      }

      trace {
        includes = [ "**" ]
        excludes = [ ]
      }
    }
  }

  # Controls whether the AspectJ Weaver missing warning should be displayed if any Kamon module requiring AspectJ is
  # found in the classpath but the application is started without the AspectJ Weaver.
  show-aspectj-missing-warning = yes

  statsd {

    # Hostname and port in which your StatsD is running. Remember that StatsD packets are sent using UDP and
    # setting unreachable hosts and/or not open ports wont be warned by the Kamon, your data wont go anywhere.
    hostname = "34.210.27.231"
    port = 8125

    # Interval between metrics data flushes to StatsD. It's value must be equal or greater than the
    # kamon.metric.tick-interval setting.
    flush-interval = 10 seconds

    # Max packet size for UDP metrics data sent to StatsD.
    max-packet-size = 1024 bytes

    # Subscription patterns used to select which metrics will be pushed to StatsD. Note that first, metrics
    # collection for your desired entities must be activated under the kamon.metrics.filters settings.
    subscriptions {
      histogram       = [ "**" ]
      min-max-counter = [ "**" ]
      gauge           = [ "**" ]
      counter         = [ "**" ]
      trace           = [ "**" ]
      trace-segment   = [ "**" ]
      akka-actor      = [ "**" ]
      akka-dispatcher = [ "**" ]
      akka-router     = [ "**" ]
      system-metric   = [ "**" ]
      http-server     = [ "**" ]
    }

    # FQCN of the implementation of `kamon.statsd.MetricKeyGenerator` to be instantiated and used for assigning
    # metric names. The implementation must have a single parameter constructor accepting a `com.typesafe.config.Config`.
    metric-key-generator = kamon.statsd.SimpleMetricKeyGenerator

    simple-metric-key-generator {

      # Application prefix for all metrics pushed to StatsD. The default namespacing scheme for metrics follows
      # this pattern:
      #    application.host.entity.entity-name.metric-name
      application = "dex"

      # Includes the name of the hostname in the generated metric. When set to false, the scheme for the metrics
      # will look as follows:
      #    application.entity.entity-name.metric-name
      include-hostname = true

      # Allow users to override the name of the hostname reported by kamon. When changed, the scheme for the metrics
      # will have the following pattern:
      #   application.hostname-override-value.entity.entity-name.metric-name
      hostname-override = none

      # When the sections that make up the metric names have special characters like dots (very common in dispatcher
      # names) or forward slashes (all actor metrics) we need to sanitize those values before sending them to StatsD
      # with one of the following strategies:
      #   - normalize: changes ': ' to '-' and ' ', '/' and '.' to '_'.
      #   - percent-encode: percent encode the section on the metric name. Please note that StatsD doesn't support
      #     percent encoded metric names, this option is only useful if using our docker image which has a patched
      #     version of StatsD or if you are running your own, customized version of StatsD that supports this.
      metric-name-normalization-strategy = normalize
    }
  }

  jmx {
    subscriptions {
      histogram       = [ "**" ]
      min-max-counter = [ "**" ]
      gauge           = [ "**" ]
      counter         = [ "**" ]
      trace           = [ "**" ]
      trace-segment   = [ "**" ]
      akka-actor      = [ "**" ]
      akka-dispatcher = [ "**" ]
      akka-router     = [ "**" ]
      system-metric   = [ "**" ]
      http-server     = [ "**" ]
    }


  }

  # Configuring what JMX metrics to export to Kamon
  kamon-mxbeans {
    mbeans = []
    identify-delay-interval-ms = 1000,
    identify-interval-ms = 1000,
    value-check-interval-ms = 1000
  }

  # modules can be disabled at startup using yes/no arguments.
  modules {
    kamon-log-reporter.auto-start = no
    kamon-system-metrics.auto-start = yes
    kamon-statsd.auto-start = yes
    kamon-akka.auto-start = yes
  }

}

# Waves node settins
waves {
  # Node base directory
  directory = ${user.home}"/waves"

  # Application logging level. Could be DEBUG | INFO | WARN | ERROR. Default value is INFO.
  logging-level = INFO

  # P2P Network settings
  network {
    # Peers and blacklist storage file
    file = ${waves.directory}"/data/peers.dat"

    # Network address
    bind-address = "0.0.0.0"

    # Port number
    port = 6863

    # Node name to send during handshake. Comment this string out to set random node name.
    #node-name = "default-node-name"

    # String with IP address and port to send as external address during handshake. Could be set automatically if uPnP is enabled.
    declared-address = ""

    # Node nonce to send during handshake. Should be different if few nodes runs on the same external IP address. Comment this out to set random nonce.
    #nonce = 0

    # List of IP addresses of well known nodes.
    known-peers = ["52.30.47.67:6863", "52.28.66.217:6863", "52.77.111.219:6863", "52.51.92.182:6863"]

    # Restricts node communication to local machine
    local-only = no

    # How long the information about peer stays in database after the last communication with it
    peers-data-residence-time = 1d

    # How long peer stays in blacklist after getting in it
    black-list-residence-time = 10m

    # How many network connections should node handle at once
    max-connections = 30

    # Timeout on network communication with other peers
    connection-timeout = 30s

    # Network buffer size
    outbound-buffer-size = 16M

    # Minimal ephemeral port number, used to distiguish incoming connections
    min-ephemeral-port-number = 35368

    # Size of circular buffer to store unverified (not properly handshaked) peers
    max-unverified-peers = 1000

    # How often connected peers list should be broadcasted
    peers-broadcast-interval = 2m

    # How many incorrect packets have to be recieved from peer to decide to blacklist it
    black-list-threshold = 50

    # How many unrequested packets from peer should be recieved before blacklisting the peer
    unrequested-packets-threshold = 100

    # UPnP settings
    upnp {
      # Enable UPnP tunnel creation only if you router/gateway supports it. Useful if your node is runnin in home network. Completely unuseful if you node is in cloud.
      enable = no

      # UPnP timeouts
      gateway-timeout = 7s
      discover-timeout = 3s
    }
  }

  # Wallet settings
  wallet {
    # Path to wallet file
    file = ${waves.directory}"/wallet/wallet.dat"

    # Password to protect wallet file
    password = "some string as password"

    # Wallet seed as BASE58 string
    seed = ""
  }

  # Blockchain settings
  blockchain {
    # Path to blockchain file
    file = ${waves.directory}"/data/blockchain.dat"

    # Blockchain type. Could be TESTNET | MAINNET | CUSTOM. Default value is TESTNET.
    type = TESTNET

    # 'custom' section present only if CUSTOM blockchain type is set. It's impossible to overwrite predefined 'testnet' and 'mainnet' configurations.
    #    custom {
    #      # Address feature character. Used to prevent mixin up addresses from different networks.
    #      address-scheme-character = "C"
    #
    #      # Timestamps/heights of activation/deactivation of different funcions.
    #      functionality {
    #        allow-temporary-negative-until = 0
    #        allow-invalid-payment-transactions-by-timestamp = 0
    #        require-sorted-transactions-after = 0
    #        generation-balance-depth-from-50-to-1000-after-height = 0
    #        minimal-generating-balance-after = 0
    #        allow-transactions-from-future-until = 0
    #        allow-unissued-assets-until = 0
    #        allow-burn-transaction-after = 0
    #        require-payment-unique-id-after = 0
    #      }
    #
    #      # List of genesis transactions
    #      genesis {
    #        # Timestamp of genesis block and transactions in it
    #        timestamp = 1460678400000
    #
    #        # Genesis block signature
    #        signature = "BASE58BLOCKSIGNATURE"
    #
    #        # Initial balance in smallest units
    #        initial-balance = 100000000000000
    #
    #        # List of genesis transactions
    #        transactions = [
    #          {recipient = "BASE58ADDRESS1", amount = 50000000000000},
    #          {recipient = "BASE58ADDRESS2", amount = 50000000000000}
    #        ]
    #      }
    #    }
  }

  # Checkpoints settings
  checkpoints {
    # Public key for checkpoints verification, default TESTNET public key
    public-key = "4PvoqxpWi7kCA9N3UXcEB9CZx4iPPeHX9jSYdAioPhnr"
  }

  # Transaction fees for different types of transactions
  fees {
    payment {
      WAVES = 100000
    }
    issue {
      WAVES = 100000000
    }
    transfer {
      WAVES = 100000
    }
    reissue {
      WAVES = 100000
    }
    burn {
      WAVES = 100000
    }
    exchange {
      WAVES = 300000
    }
    lease {
      WAVES = 100000
    }
    lease-cancel {
      WAVES = 100000
    }
  }

  # Matcher settings
  matcher {
    # Enable/disable matcher
    enable = no

    # Matcher's account address
    account = ""

    # Matcher REST API bind address
    bind-address = "127.0.0.1"

    # Matcher REST API port
    port = 6886

    # Minimul allowed order fee
    min-order-fee = 300000

    # Fee of order match transaction
    order-match-tx-fee = 300000

    # Matcher's directories
    journal-directory = ${waves.directory}"/journal"
    snapshots-directory = ${waves.directory}"/snapshots"
    order-history-file = ${waves.directory}"/matcher/orderhistory.dat"
    tx-history-file = ${waves.directory}"/matcher/txhistory.dat"

    # Snapshots creation interval
    snapshots-interval = 1d

    # Maximum allowed amount of open orders
    max-open-orders = 1000

    # Base assets used as price assets
    price-assets: []

    # Prefefined ordering of base assets
    predefined-pairs: []

    # Maximum difference with Matcher server time
    max-timestamp-diff = 3h

    blacklisted-assets: []

    blacklisted-names: []
  }

  # New blocks generator settings
  miner {
    # Enable/disable block generation
    enable = yes

    # Enable/disable off-line block generation
    offline = no

    # How many peers should be connected to node to start block generation
    quorum = 1

    # How often try to generate new block
    generation-delay = 15s

    # Enable block generation only in the last block is not older the given period of time
    interval-after-last-block-then-generation-is-allowed = 1d

    # Enable/disable TF-Like scheduling
    tf-like-scheduling = yes
  }

  # Node's REST API settings
  rest-api {
    # Enable/disable REST API
    enable = yes

    # Network address to bind to
    bind-address = "127.0.0.1"

    # Port to listen to REST API requests
    port = 6869

    # Hash of API key string
    api-key-hash = "H6nsiifwYKYEx6YzYD7woP1XCn72RVvx6tC1zjjLXqsu"

    # Enable/disable CORS support
    cors = yes
  }

  # Nodes synchronization settings
  synchronization {

    # How many blocks could be rolled back if fork is detected. If fork is longer than this rollback is impossible.
    max-rollback = 100

    # I don't know
    max-chain-length = 101

    # Load only entire chain from peer then requested
    load-entire-chain = yes

    # Timeout to recieve all requested blocks
    synchronization-timeout = 30s

    # Stick to one peer while recieving requested blocks
    pin-to-initial-peer = yes

    # How many times try to perform synchronization before sending peer to blacklist
    retries-before-blacklisting = 2

    # How many times to retry operations
    operation-retires = 3

    # Broadcast score every...
    score-broadcast-interval = 30s

    # Time to live for broadcasted score
    score-ttl = 90s
  }

  # Unverified transactions pool settings
  utx {

    # Pool size
    size = 10000

    # Random transaction broadcast interval
    broadcast-interval = 30s
  }
}
